/*
In contrast to the rest of the app, this file is licensed under the Unlicense:

This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
For more information, please refer to https://unlicense.org
*/

syntax = "proto3";

// Feel free to change these values to fit the structure of your own implementation.
package tgui.proto0;
option java_package = "com.termux.gui.protocol.protobuf.v0";


/*
Protocol

For establishing the connection, see https://github.com/termux/termux-gui/blob/main/Protocol.md#connection . Here is the relevant part:

The program has to open 2 AF_UNIX SO_STREAM server sockets in the abstract linux namespace and listen to new connections.
One of these Sockets is used as the main communication socket with the plugin, the other one is used to send asynchronous event data to the program, eg. click events.

The program then has to send a broadcast to com.termux.gui/.GUIReceiver with the string extra mainSocket and the string extra eventSocket, the values of which specify the socket name used for that communication type. The names have to be transferred without the leading null byte required to specify the abstract linux namespace.
Delivering the broadcast can be easily done with the am command:
am broadcast --user 0 -n com.termux.gui/.GUIReceiver --es mainSocket mainSocketName --es eventSocket eventSocketName

For additional security, the program should check if the connected peer has the same user id as the program itself, to ensure only the plugin can accept the connection.



Each message is send delimited, that is the size of the message is send as a varint first.  
All protocol buffer implementations should allow you to read the varint or a delimited message directly.

Events are send via the Event message, with the oneof sent to the actual event.
Methods are called with the Method message, with the oneof set to the request you want to do.
After a request, the corresponding response is send back.

 */



// Types used by multiple messages

/*
Possible Activity orientation settings. See https://developer.android.com/reference/android/R.attr#screenOrientation for the meanings.
 */
enum Orientation {
  unspecified = 0;
  behind = 1;
  fullSensor = 2;
  fullUser = 3;
  landscape = 4;
  locked = 5;
  nosensor = 6;
  portrait = 7;
  reverseLandscape = 8;
  reversePortrait = 9;
  sensor = 10;
  sensorLandscape = 11;
  sensorPortrait = 12;
  user = 13;
  userLandscape = 14;
  userPortrait = 15;
}

/*
The configuration of an Activity.
 */
message Configuration {
  /*
  Is dark mode enabled?
   */
  bool darkMode = 2;
  /*
  The current country code.
   */
  string country = 3;
  /*
  The current language code.
   */
  string language = 4;
  /*
  The current screen orientation.
  Only valid values are landscape, portrait and unspecified
   */
  Orientation orientation = 5;
  /*
  Is the software keyboard showing?
   */
  bool keyboardHidden = 6;
  /*
  Screen width in pixels.
   */
  int32 screenWidth = 7;
  /*
  Screen height in pixels.
   */
  int32 screenHeight = 8;
  /*
  The font scale, such that sp = fontscale * px
   */
  float fontscale = 9;
  /*
  The density of the display.
   */
  float density = 10;
}

/*
Visibility states for Views.
 */
enum Visibility {
    /*
    The View is visible.
     */
    visible = 0;
    /*
    The View is invisible, but takes up space in the layout.
     */
    hidden = 1;
    /*
    The View is invisible and doesn't take up space in the layout.
     */
    gone = 2;
}

/*
Information necessary for the creation of View, encapsulated as a message type for simplicity.
 */
message Create {
  /*
  The Activity of the View.
   */
  int32 aid = 1;
  /*
  The parent View id. Use -1 if you want to set the top level View.
   */
  int32 parent = 2;
  /*
  The initial visibility.
   */
  Visibility v = 3;
}


/*
Information uniquely identifying a View.
 */
message View {
  /*
  The Activity of the View.
   */
  int32 aid = 1;
  /*
  The id of the View in the Activity.
   */
  int32 id = 2;
}

/*
Directions for applying paddings and margins.
 */
enum Direction {
  /*
  Use all directions.
   */
  ALL = 0;
  TOP = 1;
  LEFT = 2;
  BOTTOM = 3;
  RIGHT = 4;
}

/*
Importance values for notifications.
 */
enum Importance {
  DEFAULT = 0;
  MIN = 1;
  LOW = 2;
  HIGH = 3;
  MAX = 4;
}

/*
The protobuf implementation allows you to specify more size units, so it's encapsulated in a message type.
 */
message Size {
  /*
  The value.
   */
  float value = 1;
  // see https://developer.android.com/guide/topics/resources/more-resources.html#Dimension
  enum Unit {
    dp = 0; // density-independent pixels
    sp = 1; // scale-independent pixels
    px = 2; // pixels
    mm = 3; // millimeters
    in = 4; // inches
    pt = 5; // points
  }
  /*
  The unit of the value.
   */
  Unit unit = 2;
}


/*
A type for View sizing.
Only used for setWidth and setHeight, to include the special constants MATCH_PARENT and WRAP_CONTENT.
 */
message ViewSize {
  /*
  Special constants.
   */
  enum Constant {
    /*
    Math the parent size.
     */
    MATCH_PARENT = 0;
    /*
    Match the content size
     */
    WRAP_CONTENT = 1;
  }
  /*
  The value is either a constant or a size value.
   */
  oneof value {
    Size size = 1;
    Constant constant = 2;
  }
}

/*
Error return codes as failure reasons for unsuccessful methods.
0 means no error, negative numbers are non-fatal informational codes send along a successful method if needed, positive codes are fatal errors send with failed methods.
 */
enum Error {
  /*
  No error.
   */
  OK = 0;
  /*
  The Activity the method tried to act on has been stopped by the system.
  Retry the method when you get a start event for the Activity.
   */
  ACTIVITY_STOPPED = 1;
  /*
  The Activity the method tried to act on has been destroyed, or was never created (in case an invalid id was used).
   */
  INVALID_ACTIVITY = 2;
  /*
  An exception occurred while handling the method. Retrying the method or issuing other methods may or may not work, depending on the type of error.
   */
  INTERNAL_ERROR = 3;
  /*
  The View id wasn't found in the Activity.
   */
  INVALID_VIEW = 4;
  /*
  The View id was found, but doesn't correspond to a valid View type for the method.
   */
  INVALID_VIEW_TYPE = 5;
  /*
  The remote layout with the specified ID wasn't found.
   */
  INVALID_REMOTE_LAYOUT = 6;
  /*
  An image was too big to be used by Android. Images for remote ImageViews and Task icons have to be smaller than 2 MB.
   */
  IMAGE_TOO_BIG = 7;
  /*
  The specified notification channel wasn't found.
   */
  CHANNEL_NOT_FOUND = 8;
  /*
  The specified notification widget wasn't found.
   */
  WIDGET_NOT_FOUND = 9;
  /*
  An enumeration value wasn't recognized.
   */
  INVALID_ENUM = 10;
  /*
  The specified Task id wasn't found.
   */
  TASK_NOT_FOUND = 11;
  /*
  The ratio in SetPiPParamsRequest was out of range for Android PiP window ratios.
   */
  INVALID_RATIO = 12;
  /*
  The method can't work, because the feature was introduced in a later Android version.
   */
  ANDROID_VERSION_TOO_LOW = 13;
  /*
  The specified buffer wasn't found.
   */
  BUFFER_NOT_FOUND = 14;
}




// Request and response types



// Activity, Task and global methods

/*
Create a new Activity.
 */
message NewActivityRequest {
  /*
  Use -1 to start in a new Task stack.
   */
  int32 tid = 1;
  /*
  The type of Activity that you want to launch.
   */
  enum ActivityType {
    /*
    A normal Activity.
     */
    normal = 0;
    /*
    Launch as a dialog. Is destroyed when the user navigates away or clicks outside.
     */
    dialog = 1;
    /*
    Launch as a dialog. Is destroyed when the user navigates away.
     */
    dialogCancelOutside = 2;
    /*
    Launch in PiP-mode.
     */
    pip = 3;
    /*
    Display also on the lockscreen.
    Make sure the Activity is secure, as the device doesn't need to be unlocked to interact with the Activity.
     */
    lockscreen = 4;
    /*
    Display in an overlay over everything else like Termux:Float.
     */
    overlay = 5;
  }
  /*
  The type you want to launch.
   */
  ActivityType type = 2;
  /*
  Whether the back button is intercepted and send as an event instead of closing the Activity or not.
   */
  bool interceptBackButton = 3;
}

/*
A message with aid = -1 and tid = -1 indicates an error.
For overlays, the tid is invalid though.
 */
message NewActivityResponse {
  /*
  The id of the new Activity.
   */
  int32 aid = 1;
  /*
  The id of the Task of the Activity.
   */
  int32 tid = 2;
}

/*
Finish an Activity.
 */
message FinishActivityRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
}

message FinishActivityResponse {
  bool success = 1;
  Error code = 2;
}

/*
Finish a Task, including all its Activities.
 */
message FinishTaskRequest {
  /*
  The id of the Task.
   */
  int32 tid = 1;
}

message FinishTaskResponse {
  bool success = 1;
  Error code = 2;
}

/*
Bring a Task to the front, showing it to the user.
 */
message BringTaskToFrontRequest {
  /*
  The id of the Task.
   */
  int32 tid = 1;
}

message BringTaskToFrontResponse {
  bool success = 1;
  Error code = 2;
}

/*
Move a Task to the back, hiding it and returning the user to the homescreen.
 */
message MoveTaskToBackRequest {
  /*
  The id of an Activity in the Task.
   */
  int32 aid = 1;
}

message MoveTaskToBackResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the Activity theme.
The text color is only applied to newly created Views, not retroactively.
 */
message SetThemeRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  The status bar color.
   */
  uint32 statusBarColor = 2;
  /*
  The primary color.
   */
  uint32 colorPrimary = 3;
  /*
  The background color.
   */
  uint32 windowBackground = 4;
  /*
  The text color.
   */
  uint32 textColor = 5;
  /*
  The accent color.
   */
  uint32 colorAccent = 6;
}

message SetThemeResponse {
  bool success = 1;
  Error code = 2;
}


message SetTaskDescriptionRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  Images have to be a PNG or JPEG file in binary format (not base64 encoded like for JSON).
  If empty (length 0), resets the icon to the default.
   */
  bytes img = 2;
  /*
  The Activity label (seems unused in Android).
   */
  string label = 3;
}

message SetTaskDescriptionResponse {
  bool success = 1;
  Error code = 2;
}

/*
Configures the PiP-mode of the Activity.
 */
message SetPiPParamsRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  The numerator of the aspect ratio.
   */
  uint32 num = 2;
  /*
  The denominator of the aspect ratio.
   */
  uint32 den = 3;
}

message SetPiPParamsResponse {
  bool success = 1;
  Error code = 2;
}

/*
Configures how the Activity responds to the software keyboard.
 */
message SetInputModeRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  How the Activity responds to the software keyboard.
   */
  enum InputMode {
    /*
    Pan the Activity, hiding some content at the top to make room for the keyboard.
     */
    pan = 0;
    /*
    Resize the Activity, shifting the Layout to make room for the keyboard.
     */
    resize = 1;
  }
  /*
  The requested mode.
   */
  InputMode mode = 2;
}

message SetInputModeResponse {
  bool success = 1;
  Error code = 2;
}

/*
Enter or leave PiP-mode.
 */
message SetPiPModeRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  Whether PiP-mode should be enabled.
   */
  bool pip = 2;
}

message SetPiPModeResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set whether PiP-mode should be entered automatically when the user exits the Activity.
 */
message SetPiPModeAutoRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  Whether PiP-mode should be entered automatically when the user exits the Activity.
   */
  bool pip = 2;
}

message SetPiPModeAutoResponse {
  bool success = 1;
  Error code = 2;
}

/*
Send a Toast.
 */
message ToastRequest {
  /*
  The text to display.
   */
  string text = 1;
  /*
  Whether the text should be displayed for a loner or shorter time.
   */
  bool long = 2;
}

message ToastResponse {
  bool success = 1;
  Error code = 2;
}

/*
Requests to keep the screen on while the Activity is shown.
 */
message KeepScreenOnRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  Whether to keep the screen on while the Activity is shown.
   */
  bool on = 2;
}

message KeepScreenOnResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set the Orientation of the Activity.
 */
message SetOrientationRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  The orientation value.
   */
  Orientation orientation = 2;
}

message SetOrientationResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set the position of an overlay Activity.
 */
message SetPositionRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  The x position in pixels from the left.
   */
  uint32 x = 2;
  /*
  The y position in pixels from the top.
   */
  uint32 y = 3;
}

message SetPositionResponse {
  bool success = 1;
  Error code = 2;
}

/*
Get the current Activity configuration.
 */
message GetConfigurationRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
}

message GetConfigurationResponse {
  bool success = 1;
  Configuration configuration = 2;
  Error code = 3;
}

/*
Turn the screen on.
 */
message TurnScreenOnRequest {
  
}

message TurnScreenOnResponse {
  bool success = 1;
  Error code = 2;
}

/*
Check whether the device is locked.
 */
message IsLockedRequest {
  
}

message IsLockedResponse {
  /*
  Possible lock states.
   */
  enum Locked {
    /*
    Lock state unknown.
     */
    UNKNOWN = 0;
    /*
    Device locked.
     */
    LOCKED = 1;
    /*
    Device unlocked.
     */
    UNLOCKED = 2;
  }
  /*
  Current lock state.
   */
  Locked locked = 1;
}

/*
Request an unlock. Will bring up the UI for the user to unlock the device.
 */
message RequestUnlockRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
}

message RequestUnlockResponse {
  bool success = 1;
  Error code = 2;
}

/*
Hide the software keyboard.
 */
message HideSoftKeyboardRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
}

message HideSoftKeyboardResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets whether the back button is intercepted. See NewActivityRequest.
 */
message InterceptBackButtonRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  bool intercept = 2;
}

message InterceptBackButtonResponse {
  bool success = 1;
  Error code = 2;
}


/*
Sets whether the volume button(s) is intercepted. Instead of changing the volume, you will get an event.
 */
message InterceptVolumeButtonRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  Whether to intercept volume up.
   */
  bool interceptUp = 2;
  /*
  Whether to intercept volume down.
   */
  bool interceptDown = 3;
}

message InterceptVolumeButtonResponse {
  bool success = 1;
  Error code = 2;
}


/*
Sets the behaviour of the status and navigation bar.
 */
message ConfigureInsetsRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  /*
  Which bars should be hidden/shown.
   */
  enum Bars {
    /*
    Both the navigation and the status bar.
     */
    BOTH_BARS = 0;
    /*
    Navigation bar only.
     */
    NAVIGATION_BAR = 1;
    /*
    Status bar only.
     */
    STATUS_BAR = 2;
    /*
    No bar.
     */
    NO_BAR = 3;
  }
  /*
  How the hidden bars should behave.
   */
  enum BarBehaviour {
    /*
    Show the bars on system gestures like swipe from the top or the bottom of the screen.
     */
    BAR_BEHAVIOUR_DEFAULT = 0;
    /*
    Like BAR_BEHAVIOUR_DEFAULT, but the bars will be shown transparent, temporarily and overlay over the window.
     */
    BAR_BEHAVIOUR_TRANSIENT = 1;
  }
  /*
  The bars that should be shown.
   */
  Bars shown = 2;
  /*
  How the bars should behave to user input.
   */
  BarBehaviour behaviour = 3;
  /*
  Whether the Activity will be shown under display cutouts. This is a no-op before API level 30.
   */
  bool underCutout = 4;
  
}

message ConfigureInsetsResponse {
  bool success = 1;
  Error code = 2;
}


/*
Get the plugin version code.
 */
message GetVersionRequest {
  
}

message GetVersionResponse {
  int32 versionCode = 1;
}

/*
Set the secure flag for the Activity, making screenshots impossible and showing a blank Activity in the task switcher if on.
 */
message SetSecureFlagRequest {
  /*
  The id of the Activity.
   */
  int32 aid = 1;
  bool secure = 2;
}

message SetSecureFlagResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set the logging level for this connection.
 */
message SetLogLevelRequest {
  /*
  The log level.
  Should be from 0 to 10 (inclusive).
   */
  uint32 level = 1;
}

message SetLogLevelResponse {
  bool success = 1;
}


/*
Gets the log for this connection.
 */
message GetLogRequest {
  /*
  Whether to clear the log after getting it.
   */
  bool clear = 1;
}

message GetLogResponse {
  bool success = 1;
  /*
  The log for this connection.
   */
  string log = 2;
}



// View creation methods

/*
All these methods work the same:
data is a Create submessage filled with information about the View to create: The visibility, the Activity and the parent View.
All other fields are specific to each View type and explained in each message type.

For all creation responses, an id of -1 indicates a failure.
In other cases, a valid View id for further methods is returned.
 */


message CreateLinearLayoutRequest {
  Create data = 1;
  /*
  Whether the LineaLayout lays out its children horizontally or vertically.
   */
  bool horizontal = 2;
}

message CreateLinearLayoutResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateFrameLayoutRequest {
  Create data = 1;
}

message CreateFrameLayoutResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateSwipeRefreshLayoutRequest {
  Create data = 1;
}

message CreateSwipeRefreshLayoutResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateTextViewRequest {
  Create data = 1;
  /*
  The initial text.
   */
  string text = 2;
  /*
  Sets the text to be selectable by the user.
   */
  bool selectableText = 3;
  /*
  Sets links to be clickable by the user.
   */
  bool clickableLinks = 4;
}

message CreateTextViewResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateEditTextRequest {
  Create data = 1;
  /*
  A small line is displayed under an EditText. This option removes it.
   */
  bool noline = 2;
  /*
  The type of input. Determines the layout of keys in the software keyboard.
  See https://developer.android.com/reference/android/text/InputType .
   */
  enum Type {
    text = 0;
    textMultiLine = 1;
    phone = 3;
    date = 4;
    time = 5;
    datetime = 6;
    number = 7;
    numberDecimal = 8;
    numberPassword = 9;
    numberSigned = 10;
    numberDecimalSigned = 11;
    textEmailAddress = 12;
    textPassword = 13;
  }
  /*
  The content type.
   */
  Type type = 3;
  /*
  The initial text.
   */
  string txt = 4;
}

message CreateEditTextResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateButtonRequest {
  Create data = 1;
  /*
  Whether the text should be in small caps.
   */
  bool allcaps = 2;
  /*
  The initial text.
   */
  string text = 3;
}

message CreateButtonResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateImageViewRequest {
  Create data = 1;
  /*
  If true, makes the ImageView work with the soft & hardware keyboard and send key events
   */
  bool keyboard = 2;
}

message CreateImageViewResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateSpaceRequest {
  Create data = 1;
}

message CreateSpaceResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateNestedScrollViewRequest {
  Create data = 1;
  /*
  Snaps to children.
   */
  bool snapping = 2;
  /*
  Visibility of the scroll bar.
   */
  bool nobar = 3;
  /*
  Makes the View take up the whole with/height, event if the content doesn't require it.
   */
  bool fillViewport = 4;
}

message CreateNestedScrollViewResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateHorizontalScrollViewRequest {
  Create data = 1;
  /*
  Snaps to children.
   */
  bool snapping = 2;
  /*
  Visibility of the scroll bar.
   */
  bool nobar = 3;
  /*
  Makes the View take up the whole with/height, event if the content doesn't require it.
   */
  bool fillViewPort = 4;
}

message CreateHorizontalScrollViewResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateRadioButtonRequest {
  Create data = 1;
  /*
  The initial text.
   */
  string text = 2;
  /*
  The initial checked status.
   */
  bool checked = 3;
}

message CreateRadioButtonResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateRadioGroupRequest {
  Create data = 1;
}

message CreateRadioGroupResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateCheckboxRequest {
  Create data = 1;
  /*
  The initial text.
   */
  string text = 2;
  /*
  The initial checked status.
   */
  bool checked = 3;
}

message CreateCheckboxResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateToggleButtonRequest {
  Create data = 1;
  /*
  The initial checked status.
   */
  bool checked = 2;
}

message CreateToggleButtonResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateSwitchRequest {
  Create data = 1;
  /*
  The initial text.
   */
  string text = 2;
  /*
  The initial checked status.
   */
  bool checked = 3;
}

message CreateSwitchResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateSpinnerRequest {
  Create data = 1;
}

message CreateSpinnerResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateProgressBarRequest {
  Create data = 1;
}

message CreateProgressBarResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateTabLayoutRequest {
  Create data = 1;
}

message CreateTabLayoutResponse {
  int32 id = 1;
  Error code = 2;
}

message CreateGridLayoutRequest {
  Create data = 1;
  /*
  The number of rows in the layout.
   */
  uint32 rows = 2;
  /*
  The number of columns in the layout.
   */
  uint32 cols = 3;
}

message CreateGridLayoutResponse {
  int32 id = 1;
  Error code = 2;
}

message CreateWebViewRequest {
  Create data = 1;
}

message CreateWebViewResponse {
  int32 id = 1;
  Error code = 2;
}


message CreateSurfaceViewRequest {
  Create data = 1;
  /*
  If true, makes the SurfaceView work with the soft & hardware keyboard and send key events
   */
  bool keyboard = 2;
  /*
  Secure flag, like for Activities.
   */
  bool secure = 6;
}

message CreateSurfaceViewResponse {
  int32 id = 1;
  Error code = 2;
}



// View manipulation methods

/*
Sets whether the cursor is shown in an EditText.
 */
message ShowCursorRequest {
  View v = 1;
  /*
  Whether the cursor is shown.
   */
  bool show = 2;
}

message ShowCursorResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets View parameters for Views in a LinearLayout.
 */
message SetLinearLayoutParamsRequest {
  View v = 1;
  /*
  Use a negative number to keep the current weight.
   */
  float weight = 2;
  /*
  Use 0 to keep the current position. The position starts at 1, to make the default message smaller.
   */
  int32 position = 3;
}

message SetLinearLayoutParamsResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets View parameters for Views in a GridLayout.
 */
message SetGridLayoutParamsRequest {
  View v = 1;
  /*
  The starting row of the View.
   */
  int32 row = 2;
  /*
  The starting column of the View.
   */
  int32 col = 3;
  /*
  The amount of rows the View should occupy.
   */
  int32 rowSize = 4;
  /*
  The amount of columns the View should occupy.
   */
  int32 colSize = 5;
  /*
  Alignment of the View inside the cell.
   */
  enum Alignment {
    CENTER = 0;
    TOP = 1;
    BOTTOM = 2;
    LEFT = 3;
    RIGHT = 4;
    BASELINE = 5;
    FILL = 6;
  }
  /*
  Alignment of the View in the row.
   */
  Alignment rowAlign = 6;
  /*
  Alignment of the View in the column.
   */
  Alignment colAlign = 7;
}

message SetGridLayoutParamsResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the absolute position of a View. Useful in a FrameLayout.
Can also set the View to show on top of the others in the Layout.
 */
message SetViewLocationRequest {
  View v = 1;
  // The unit for x and y
  Size.Unit unit = 2;
  float x = 3;
  float y = 4;
  /*
  Whether to show on top of the siblings.
   */
  bool top = 5;
}

message SetViewLocationResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets View parameters for Views in a RelativeLayout.
 */
message SetRelativeLayoutParamsRequest {
  View v = 1;
}

message SetRelativeLayoutParamsResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the View visibility.
 */
message SetVisibilityRequest {
  View v = 1;
  Visibility vis = 2;
}

message SetVisibilityResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the View width.
 */
message SetWidthRequest {
  View v = 1;
  ViewSize s = 2;
}

message SetWidthResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the View height.
 */
message SetHeightRequest {
  View v = 1;
  ViewSize s = 2;
}

message SetHeightResponse {
  bool success = 1;
  Error code = 2;
}

/*
Gets the View size in a specified unit.
 */
message GetDimensionsRequest {
  View v = 1;
  /*
  The unit for the returned size.
   */
  Size.Unit unit = 2;
}

message GetDimensionsResponse {
  /*
  Negative values for one of these denote an error.
   */
  float width = 1;
  float height = 2;
  Error code = 3;
}

/*
Removes a View.
 */
message DeleteViewRequest {
  View v = 1;
}

message DeleteViewResponse {
  bool success = 1;
  Error code = 2;
}

/*
Removes the children of a View.
 */
message DeleteChildrenRequest {
  View v = 1;
}

message DeleteChildrenResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the margins of a View.
 */
message SetMarginRequest {
  View v = 1;
  /*
  The margin size.
   */
  Size s = 2;
  /*
  The direction for the margin to apply.
   */
  Direction dir = 3;
}

message SetMarginResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the padding of a View.
 */
message SetPaddingRequest {
  View v = 1;
  /*
  The padding size.
   */
  Size s = 2;
  /*
  The direction for the padding to apply.
   */
  Direction dir = 3;
}

message SetPaddingResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the background color of a View.
 */
message SetBackgroundColorRequest {
  View v = 1;
  uint32 color = 2;
}

message SetBackgroundColorResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the text color of a View.
 */
message SetTextColorRequest {
  View v = 1;
  uint32 color = 2;
}

message SetTextColorResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the progress of a ProgressBar.
 */
message SetProgressRequest {
  View v = 1;
  /*
  THe progress from 0 to 100 (inclusive).
   */
  uint32 progress = 2;
}

message SetProgressResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets whether a SwipeRefreshLayout is in the refreshing state.
You have to set this to false when your refreshing action has completed.
 */
message SetRefreshingRequest {
  View v = 1;
  bool refreshing = 2;
}

message SetRefreshingResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the Text of a View.
 */
message SetTextRequest {
  View v = 1;
  string text = 2;
}

message SetTextResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the gravity of the text in a View.
 */
message SetGravityRequest {
  View v = 1;
  /*
  Gravity values.
   */
  enum Gravity {
    /*
    Center the text.
     */
    CENTER = 0;
    /*
    Align to the top/left.
     */
    LEFTTOP = 1;
    /*
    Align to the right/bottom.
     */
    RIGHTBOTTOM = 2;
  }
  /*
  The horizontal gravity.
   */
  Gravity horizontal = 2;
  /*
  The vertical gravity.
   */
  Gravity vertical = 3;
}

message SetGravityResponse {
  bool success = 1;
  Error code = 2;
}

/*
Sets the text size for a View.
 */
message SetTextSizeRequest {
  View v = 1;
  Size s = 2;
}

message SetTextSizeResponse {
  bool success = 1;
  Error code = 2;
}

/*
Gets the text in a View.
 */
message GetTextRequest {
  View v = 1;
}

message GetTextResponse {
  bool success = 1;
  /*
  The text of the View.
   */
  string text = 2;
  Error code = 3;
}

/*
Sets whether a View is checked, like a CheckBox, RadioButton, Switch or ToggleButton.
 */
message SetCheckedRequest {
  View v = 1;
  bool checked = 2;
}

message SetCheckedResponse {
  bool success = 1;
  Error code = 2;
}

/*
Shift the focus to a View.
 */
message RequestFocusRequest {
  View v = 1;
  bool forcesoft = 2;
}

message RequestFocusResponse {
  bool success = 1;
  Error code = 2;
}

/*
Gets the scroll position of a NestedScrollVIew or HorizontalScrollView.
 */
message GetScrollPositionRequest {
  View v = 1;
  /*
  The unit of the scroll amounts.
   */
  Size.Unit unit = 2;
}

message GetScrollPositionResponse {
  /*
  Negative values for one of these denote an error.
   */
  float x = 1;
  float y = 2;
  Error code = 3;
}

/*
Sets the scroll position of a NestedScrollVIew or HorizontalScrollView.
 */
message SetScrollPositionRequest {
  View v = 1;
  /*
  The horizontal scroll.
   */
  Size x = 2;
  /*
  The vertical scroll.
   */
  Size y = 3;
  /*
  Whether to scroll abruptly or smooth to the position.
   */
  bool smooth = 4;
}

message SetScrollPositionResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set the items of a Spinner.
 */
message SetListRequest {
  View v = 1;
  /*
  The items to be displayed in the spinner.
   */
  repeated string list = 2;
}

message SetListResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set the image of an ImageView.
 */
message SetImageRequest {
  View v = 1;
  /*
  The image. Has to be a PNG/JPG.
   */
  bytes image = 2;
}

message SetImageResponse {
  bool success = 1;
  Error code = 2;
}

/*
Creates a shared memory buffer.

This is a method that doesn't generate a message as a response.
Instead the buffer id is send as a signed 32bit integer.
If the integer is negative, creation failed.
If the integer is positive, creation succeeded and you will get another byte (the value can be discarded)
with a file descriptor for the memory region as ancillary data.

 */
message AddBufferRequest {
  /*
  Available color formats.
   */
  enum Format {
    /*
    Use the ARGB8888 format.
     */
    ARGB8888 = 0;
  }
  /*
  The buffer format.
   */
  Format f = 1;
  /*
  The buffer width.
   */
  uint32 width = 2;
  /*
  The buffer height.
   */
  uint32 height = 3;
}

/*
Deletes a shared buffer.
To actually free the memory, you also have to unmap it and close the file descriptor you received.
 */
message DeleteBufferRequest {
  int32 buffer = 1;
}

message DeleteBufferResponse {
  bool success = 1;
  Error code = 2;
}

/*
Blit the buffer to the underlying image inside the plugin.
Refreshing ImageViews or setting the ImageView to show this buffer will now show the updated contents.
 */
message BlitBufferRequest {
  int32 buffer = 1;
}

message BlitBufferResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set an ImageView to show the contents of a shared memory buffer.
 */
message SetBufferRequest {
  View v = 1;
  int32 buffer = 2;
}

message SetBufferResponse {
  bool success = 1;
  Error code = 2;
}

/*
Refresh an ImageView after blitting the buffer it uses to show the new image.
 */
message RefreshImageViewRequest {
  View v = 1;
}

message RefreshImageViewResponse {
  bool success = 1;
  Error code = 2;
}

/*
Select a tab in a TabLayout.
 */
message SelectTabRequest {
  View v = 1;
  uint32 tab = 2;
}

message SelectTabResponse {
  bool success = 1;
  Error code = 2;
}

/*
Select an item in a Spinner.
 */
message SelectItemRequest {
  View v = 1;
  uint32 item = 2;
}

message SelectItemResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set whether a View should be clickable. Click events have to be enabled separately.
Conversely, setting a View to emit click events automatically marks it a clickable.
 */
message SetClickableRequest {
  View v = 1;
  bool clickable = 2;
}

message SetClickableResponse {
  bool success = 1;
  Error code = 2;
}










// RemoteViews methods

/*
RemoteViews are more limited Views used for custom notification layouts and widgets.
Most methods work like the View methods.
 */

/*
Create a new remote layout. You can then place remote Views in the layout.
 */
message CreateRemoteLayoutRequest {
  
}

message CreateRemoteLayoutResponse {
  // an rid of -1 indicates a failure.
  int32 rid = 1;
  Error code = 2;
}

/*
Delete a remote Layout.
 */
message DeleteRemoteLayoutRequest {
  int32 rid = 1;
}

message DeleteRemoteLayoutResponse {
  bool success = 1;
  Error code = 2;
}

/*
As with the normal create messages, an id of -1 indicates a failure.
 */

message AddRemoteFrameLayoutRequest {
  int32 rid = 1;
  int32 parent = 2;
}

message AddRemoteFrameLayoutResponse {
  int32 id = 1;
  Error code = 2;
}


message AddRemoteLinearLayoutRequest {
  int32 rid = 1;
  int32 parent = 2;
  bool horizontal = 3;
}

message AddRemoteLinearLayoutResponse {
  int32 id = 1;
  Error code = 2;
}


message AddRemoteTextViewRequest {
  int32 rid = 1;
  int32 parent = 2;
}

message AddRemoteTextViewResponse {
  int32 id = 1;
  Error code = 2;
}


message AddRemoteButtonRequest {
  int32 rid = 1;
  int32 parent = 2;
}

message AddRemoteButtonResponse {
  int32 id = 1;
  Error code = 2;
}


message AddRemoteImageViewRequest {
  int32 rid = 1;
  int32 parent = 2;
}

message AddRemoteImageViewResponse {
  int32 id = 1;
  Error code = 2;
}


message AddRemoteProgressBarRequest {
  int32 rid = 1;
  int32 parent = 2;
}

message AddRemoteProgressBarResponse {
  int32 id = 1;
  Error code = 2;
}


message SetRemoteBackgroundColorRequest {
  int32 rid = 1;
  int32 id = 2;
  uint32 color = 3;
}

message SetRemoteBackgroundColorResponse {
  bool success = 1;
  Error code = 2;
}


message SetRemoteProgressBarRequest {
  int32 rid = 1;
  int32 id = 2;
  uint32 progress = 3;
  /*
  For remote progress bars you get to choose the maximum value.
   */
  uint32 max = 4;
}

message SetRemoteProgressBarResponse {
  bool success = 1;
  Error code = 2;
}


message SetRemoteTextRequest {
  int32 rid = 1;
  int32 id = 2;
  string text = 3;
}

message SetRemoteTextResponse {
  bool success = 1;
  Error code = 2;
}


message SetRemoteTextSizeRequest {
  int32 rid = 1;
  int32 id = 2;
  Size s = 3;
}

message SetRemoteTextSizeResponse {
  bool success = 1;
  Error code = 2;
}


message SetRemoteTextColorRequest {
  int32 rid = 1;
  int32 id = 2;
  uint32 color = 3;
}

message SetRemoteTextColorResponse {
  bool success = 1;
  Error code = 2;
}


message SetRemoteVisibilityRequest {
  int32 rid = 1;
  int32 id = 2;
  Visibility v = 3;
}

message SetRemoteVisibilityResponse {
  bool success = 1;
  Error code = 2;
}


message SetRemotePaddingRequest {
  int32 rid = 1;
  int32 id = 2;
  Size left = 3;
  Size top = 4;
  Size right = 5;
  Size bottom = 6;
}

message SetRemotePaddingResponse {
  bool success = 1;
  Error code = 2;
}

/*
Beware, the Image has to be smaller than 2 MB.
 */
message SetRemoteImageRequest {
  int32 rid = 1;
  int32 id = 2;
  bytes image = 3;
}

message SetRemoteImageResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set a Widget to show a remote layout.
 */
message SetWidgetLayoutRequest {
  int32 rid = 1;
  string wid = 2;
}

message SetWidgetLayoutResponse {
  bool success = 1;
  Error code = 2;
}




// WebView methods

/*
Allow Javascript to run in the WebView.
The user gets asked for this and can deny it.
 */
message AllowJavascriptRequest {
  View v = 1;
  bool allow = 2;
}

message AllowJavascriptResponse {
  bool success = 1;
  bool allowed = 2;
  Error code = 3;
}

/*
Allow the WebView to open content URIs.
 */
message AllowContentURIRequest {
  View v = 1;
  bool allow = 2;
}

message AllowContentURIResponse {
  bool success = 1;
  Error code = 2;
}

/*
Set the data to be shown in the WebView.
You should always set base64 to true and use base64 encoded data.
 */
message SetDataRequest {
  View v = 1;
  string data = 2;
  bool base64 = 3;
  /*
  The MIME type of the data.
   */
  string mime = 4;
}

message SetDataResponse {
  bool success = 1;
  Error code = 2;
}

/*
Load a URI in the WebView.
 */
message LoadURIRequest {
  View v = 1;
  string uri = 2;
}

message LoadURIResponse {
  bool success = 1;
  Error code = 2;
}

/*
Allow clicking links to navigate in the WebView.
 */
message AllowNavigationRequest {
  View v = 1;
  bool allow = 2;
}

message AllowNavigationResponse {
  bool success = 1;
  Error code = 2;
}

/*
Go back to the last page.
 */
message GoBackRequest {
  View v = 1;
}

message GoBackResponse {
  bool success = 1;
  Error code = 2;
}

/*
Go forward to the next page (if there is one in the back list).
 */
message GoForwardRequest {
  View v = 1;
}

message GoForwardResponse {
  bool success = 1;
  Error code = 2;
}

/*
Run Javascript in the WebView.
 */
message EvaluateJSRequest {
  View v = 1;
  string code = 2;
}

message EvaluateJSResponse {
  bool success = 1;
  Error code = 2;
}


// Notification methods

/*
Create a channel for notifications.
 */
message CreateNotificationChannelRequest {
  /*
  The id the channel should have. This isn't shown to the user, but to identify the channel.
   */
  string id = 1;
  /*
  The name of the channel shown to the user.
   */
  string name = 2;
  /*
  The initial importance of the channel. Higher means the notifications fill be more intrusive.
   */
  Importance importance = 3;
}

message CreateNotificationChannelResponse {
  bool success = 1;
  Error code = 2;
}

/*
Create a notification.
 */
message CreateNotificationRequest {
  /*
  A normal notification.
   */
  message NormalNotification {
    string title = 1;
    string content = 2;
  }
  /*
  A notification with longer text, allowing the user to expand the notification to see it all.
   */
  message LongTextNotification {
    string title = 1;
    string content = 2;
  }
  /*
  A notification showing an image.
   */
  message BigImageNotification {
    string title = 1;
    string content = 2;
    /*
    The image to show.
     */
    bytes image = 3;
    /*
    Whether to show a thumbnail when the notification is folded up.
     */
    bool asThumbnail = 4;
  }
  /*
  A notification with a custom layout.
   */
  message CustomNotification {
    /*
    The layout id for the normal layout.
     */
    int32 layout = 1;
    /*
    The layout id for an expanded layout. Optional. Set to -1 when not using.
     */
    int32 layoutExpanded = 2;
    /*
    The layout id for an HUD layout. Optional. Set to -1 when not using.
     */
    int32 layoutHUD = 3;
  }
  /*
  The main notification data.
   */
  oneof type {
    NormalNotification normal = 8;
    LongTextNotification longText = 9;
    BigImageNotification bigImage = 10;
    CustomNotification custom = 11;
  }
  /*
  Use -1 to create a new notification. Use an existing id to update a notification.
   */
  int32 id = 1;
  /*
  An icon for the notification. Optional.
   */
  bytes icon = 2;
  /*
  The channel the notification should be in.
   */
  string channel = 3;
  /*
  The importance of the notification. Newer Android versions will use the channel importance instead.
   */
  Importance importance = 4;
  /*
  Whether to alert the user only once or also on updates.
   */
  bool alertOnce = 5;
  /*
  Whether to show the timestamp.
   */
  bool showTimestamp = 6;
  /*
  Actions the user can use.
   */
  repeated string actions = 7;
  /*
  The timestamp in millisecond time since the Unix epoch.
   */
  int64 timestamp = 12;
  /*
  When a notification is ongoing, it cannot be dismissed by the user.
  All notifications will be dismissed when the connection is closed though.
   */
  bool ongoing = 13;
}

message CreateNotificationResponse {
  /*
  -1 indicates an error.
   */
  int32 id = 1;
  Error code = 2;
}

/*
Dismiss a notification.
 */
message CancelNotificationRequest {
  int32 id = 1;
}

message CancelNotificationResponse {
  bool success = 1;
  Error code = 2;
}






// Event control methods

/*
Set whether Views should send certain event types.
 */

message SendClickEventRequest {
  View v = 1;
  bool send = 2;
}

message SendClickEventResponse {
  bool success = 1;
  Error code = 2;
}


message SendLongClickEventRequest {
  View v = 1;
  bool send = 2;
}

message SendLongClickEventResponse {
  bool success = 1;
  Error code = 2;
}


message SendFocusChangeEventRequest {
  View v = 1;
  bool send = 2;
}

message SendFocusChangeEventResponse {
  bool success = 1;
  Error code = 2;
}


message SendTouchEventRequest {
  View v = 1;
  bool send = 2;
}

message SendTouchEventResponse {
  bool success = 1;
  Error code = 2;
}


message SendTextEventRequest {
  View v = 1;
  bool send = 2;
}

message SendTextEventResponse {
  bool success = 1;
  Error code = 2;
}

/*
For overlay Activities. Not reliable.
 */
message SendOverlayTouchEventRequest {
  int32 aid = 1;
  bool send = 2;
}

message SendOverlayTouchEventResponse {
  bool success = 1;
  Error code = 2;
}


// SurfaceView and HardwareBuffer methods


/*
Creates a shared HardwareBuffer for rendering with GLES or Vulkan.

The flags AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER and AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE are always set, as
the plugin reads the buffer as a texture and the client needs to write to it as a framebuffer.

This is a method that doesn't generate a message as a response.
Instead the buffer id is send as a signed 32bit integer.
If the integer is negative, creation failed.
If the integer is positive, creation succeeded and you will get the HardwareBuffer over the socket.
Receiving the HardwareBuffer has to be done with AHardwareBuffer_recvHandleFromUnixSocket from hardware_buffer.h in the NDK.

 */
message CreateHardwareBufferRequest {
  /*
  Width in pixels.
   */
  int32 width = 1;
  /*
  Height in pixels.
   */
  int32 height = 2;
  /*
  Possible buffer formats. See https://developer.android.com/ndk/reference/group/a-hardware-buffer#ahardwarebuffer_format.
   */
  enum Format {
    /*
    Corresponding to AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM.
     */
    RGBA8888 = 0;
    /*
    Corresponding to AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM.
     */
    RGBX8888 = 1;
    /*
    Corresponding to AHARDWAREBUFFER_FORMAT_R8G8B8_UNORM.
     */
    RGB888 = 2;
    /*
    Corresponding to AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM.
     */
    RGB565 = 3;
  }
  /*
  The buffer format.
   */
  Format format = 3;
  enum CPUUsage {
    never = 0;
    rarely = 1;
    often = 2;
  }
  /*
  How often the CPU will read the buffer.
   */
  CPUUsage cpuRead = 4;
  /*
  How often the CPU will write to the buffer.
   */
  CPUUsage cpuWrite = 5;
}

/*
Destroys a HardwareBuffer in the plugin.
To free the resources, you also have to destroy the HardwareBuffer in the client and unmap all texture and other mappings.
 */
message DestroyHardwareBufferRequest {
  int32 buffer = 1;
}

message DestroyHardwareBufferResponse {
  bool success = 1;
  Error code = 2;
}


/*
Sets a SurfaceView to present the contents of a HardwareBuffer.
After this method completes, the client can use the old buffer again.
If you want to unset the buffer, use -1.
-1 is returned for the old buffer if there was none.

If a buffer fits the SurfaceView size, it is displayed fully as the contents of the SurfaceView.
If the buffer is too small, it is centered in the SurfaceView.
If the buffer is too large, it is drawn such that the upper left corner starts at the upper left corner of the SurfaceView.
This is done for both dimensions independently, i.e. a SurfaceView with a size of 100 x 200 and a buffer of 50x300
gets centered horizontally in the SurfaceView, while the upper edge of the buffer aligns with the upper edge of the SurfaceView.
 */
message SurfaceViewSetBufferRequest {
  View v = 1;
  int32 buffer = 2;
}

message SurfaceViewSetBufferResponse {
  bool success = 1;
  /*
  The new buffer that is being used.
   */
  int32 newBuffer = 2;
  /*
  The old buffer that is available again.
   */
  int32 oldBuffer = 3;
  Error code = 4;
}

/*
Sets configurations for a SurfaceView.
 */
message SurfaceViewConfigRequest {
  View v = 1;
  /*
  What should happen in case the buffer dimensions for an axis don't match the Surface dimensions.
   */
  enum OnDimensionMismatch {
    /*
    The top/left side of the buffer will be displayed starting at the top/left side of the Surface.
    If the buffer is too large, the content at the bottom/right of the buffer won't be displayed.
     */
    STICK_TOPLEFT = 0;
    /*
    The content of the buffer is centered on the axis of the Surface, meaning the outer parts won't be displayed if the buffer is too large.
     */
    CENTER_AXIS = 1;
  }
  /*
  In case the buffer is too small, this is the color the rest of the surface gets filled up with
   */
  uint32 backgroundColor = 2;
  /*
  What happens on an x dimension mismatch.
   */
  OnDimensionMismatch xMismatch = 3;
  /*
  What happens on an y dimension mismatch.
   */
  OnDimensionMismatch yMismatch = 4;
  /*
  The targeted framerate for the Surface. The system doesn't need to respect this value.
  If it does, the frequency of SurfaceViewSurfaceChangedEvents changes accordingly.
  It is ignored on Android versions lower than 11.
   */
  float framerate = 5;
  
}

message SurfaceViewConfigResponse {
  bool success = 1;
  Error code = 2;
}



message Method {
  oneof method {
    // Activity, Task and global methods
    NewActivityRequest newActivity = 16;
    FinishActivityRequest finishActivity = 17;
    FinishTaskRequest finishTask = 18;
    BringTaskToFrontRequest bringTaskToFront = 19;
    MoveTaskToBackRequest moveTaskToBack = 20;
    SetThemeRequest setTheme = 21;
    SetTaskDescriptionRequest setTaskDescription = 22;
    SetPiPParamsRequest setPiPParams = 23;
    SetInputModeRequest setInputMode = 24;
    SetPiPModeRequest setPiPMode = 25;
    SetPiPModeAutoRequest setPiPModeAuto = 26;
    ToastRequest toast = 27;
    KeepScreenOnRequest keepScreenOn = 28;
    SetOrientationRequest setOrientation = 29;
    SetPositionRequest setPosition = 30;
    GetConfigurationRequest getConfiguration = 31;
    TurnScreenOnRequest turnScreenOn = 32;
    IsLockedRequest isLocked = 33;
    RequestUnlockRequest requestUnlock = 34;
    HideSoftKeyboardRequest hideSoftKeyboard = 35;
    InterceptBackButtonRequest interceptBackButton = 36;
    GetVersionRequest version = 37;
    SetSecureFlagRequest setSecure = 38;
    SetLogLevelRequest setLogLevel = 39;
    GetLogRequest getLog = 40;
    InterceptVolumeButtonRequest interceptVolume = 41;
    ConfigureInsetsRequest configInsets = 42;
    

    // View creation methods
    CreateLinearLayoutRequest createLinearLayout = 100;
    CreateFrameLayoutRequest createFrameLayout = 101;
    CreateSwipeRefreshLayoutRequest createSwipeRefreshLayout = 102;
    CreateTextViewRequest createTextView = 103;
    CreateEditTextRequest createEditText = 104;
    CreateButtonRequest createButton = 105;
    CreateImageViewRequest createImageView = 106;
    CreateSpaceRequest createSpace = 107;
    CreateNestedScrollViewRequest createNestedScrollView = 108;
    CreateHorizontalScrollViewRequest createHorizontalScrollView = 109;
    CreateRadioGroupRequest createRadioGroup = 110;
    CreateRadioButtonRequest createRadioButton = 111;
    CreateCheckboxRequest createCheckbox = 112;
    CreateToggleButtonRequest createToggleButton = 113;
    CreateSwitchRequest createSwitch = 114;
    CreateSpinnerRequest createSpinner = 115;
    CreateProgressBarRequest createProgressBar = 116;
    CreateTabLayoutRequest createTabLayout = 117;
    CreateWebViewRequest createWebView = 128;
    CreateGridLayoutRequest createGridLayout = 129;
    CreateSurfaceViewRequest createSurfaceView = 130;
    
    
    // View manipulation methods
    
    ShowCursorRequest showCursor = 200;
    SetLinearLayoutParamsRequest setLinearLayout = 201;
    SetGridLayoutParamsRequest setGridLayout = 202;
    SetViewLocationRequest setLocation = 203;
    SetRelativeLayoutParamsRequest setRelative = 204;
    SetVisibilityRequest setVisibility = 205;
    SetWidthRequest setWidth = 206;
    SetHeightRequest setHeight = 207;
    GetDimensionsRequest getDimensions = 209;
    DeleteViewRequest deleteView = 210;
    DeleteChildrenRequest deleteChildren = 211;
    SetMarginRequest setMargin = 212;
    SetPaddingRequest setPadding = 213;
    SetBackgroundColorRequest setBackgroundColor = 214;
    SetTextColorRequest setTextColor = 215;
    SetProgressRequest setProgress = 216;
    SetRefreshingRequest setRefreshing = 217;
    SetTextRequest setText = 218;
    SetGravityRequest setGravity = 219;
    SetTextSizeRequest setTextSize = 220;
    GetTextRequest getText = 221;
    RequestFocusRequest requestFocus = 222;
    GetScrollPositionRequest getScrollPosition = 223;
    SetScrollPositionRequest setScrollPosition = 224;
    SetListRequest setList = 225;
    SetImageRequest setImage = 226;
    AddBufferRequest addBuffer = 227;
    DeleteBufferRequest deleteBuffer = 228;
    BlitBufferRequest blitBuffer = 229;
    SetBufferRequest setBuffer = 230;
    RefreshImageViewRequest refreshImageView = 231;
    SelectTabRequest selectTab = 232;
    SelectItemRequest selectItem = 233;
    SetClickableRequest setClickable = 234;
    SetCheckedRequest setChecked = 235;
    
    
    // RemoteViews methods
    
    CreateRemoteLayoutRequest createRemoteLayout = 300;
    DeleteRemoteLayoutRequest deleteRemoteLayout = 301;
    AddRemoteFrameLayoutRequest addRemoteFrameLayout = 302;
    AddRemoteLinearLayoutRequest addRemoteLinearLayout = 303;
    AddRemoteTextViewRequest addRemoteTextView = 304;
    AddRemoteButtonRequest addRemoteButton = 305;
    AddRemoteImageViewRequest addRemoteImageView = 306;
    AddRemoteProgressBarRequest addRemoteProgressBar = 307;
    SetRemoteBackgroundColorRequest setRemoteBackgroundColor = 308;
    SetRemoteProgressBarRequest setRemoteProgressBar = 309;
    SetRemoteTextRequest setRemoteText = 310;
    SetRemoteTextSizeRequest setRemoteTextSize = 311;
    SetRemoteTextColorRequest setRemoteTextColor = 312;
    SetRemoteVisibilityRequest setRemoteVisibility = 313;
    SetRemotePaddingRequest setRemotePadding = 314;
    SetRemoteImageRequest setRemoteImage = 315;
    SetWidgetLayoutRequest setWidgetLayout = 316;
    
    
    
    // WebView methods
    
    AllowJavascriptRequest allowJS = 400;
    AllowContentURIRequest allowContent = 401;
    SetDataRequest setData = 402;
    LoadURIRequest loadURI = 403;
    AllowNavigationRequest allowNavigation = 404;
    GoBackRequest goBack = 405;
    GoForwardRequest goForward = 406;
    EvaluateJSRequest evaluateJS = 407;
    
    
    // Notification methods

    CreateNotificationChannelRequest createChannel = 500;
    CreateNotificationRequest createNotification = 501;
    CancelNotificationRequest cancelNotification = 502;
    
    
    
    // Event control methods
    
    SendClickEventRequest sendClickEvent = 600;
    SendLongClickEventRequest sendLongClickEvent = 601;
    SendFocusChangeEventRequest sendFocusChangeEvent = 602;
    SendTouchEventRequest sendTouchEvent = 603;
    SendTextEventRequest sendTextEvent = 604;
    SendOverlayTouchEventRequest sendOverlayTouch = 605;
    
    
    CreateHardwareBufferRequest createHardwareBuffer = 700;
    DestroyHardwareBufferRequest destroyHardwareBuffer = 701;
    SurfaceViewSetBufferRequest setSurfaceBuffer = 702;
    SurfaceViewConfigRequest surfaceConfig = 703;
    
    
  }
}





// Event types

/*
See the Android Activity lifecycle for information on these events.
 */

message CreateEvent {
  int32 aid = 1;
}

message StartEvent {
  int32 aid = 1;
}

message ResumeEvent {
  int32 aid = 1;
}

message PauseEvent {
  int32 aid = 1;
  bool finishing = 2;
}

message StopEvent {
  int32 aid = 1;
  bool finishing = 2;
}

message DestroyEvent {
  int32 aid = 1;
  bool finishing = 2;
}


/*
Send when the configuration of an Activity updates, i.e. because the screen was rotated.
 */
message ConfigEvent {
  int32 aid = 1;
  Configuration configuration = 2;
}

/*
Send when a View is clicked.
Enabled automatically for Views it makes sense for (i.e. Buttons).
 */
message ClickEvent {
  View v = 1;
  /*
  The checked status for View that can be checked.
   */
  bool set = 4;
}

/*
Send when a View is clicked and hold for some time.
 */
message LongClickEvent {
  View v = 1;
}

/*
Send when the focus changes from or to a View.
 */
message FocusChangeEvent {
  View v = 1;
  bool focus = 2;
}

/*
Send when a View is touched.
See the Android documentation for MotionEvent for info: https://developer.android.com/reference/android/view/MotionEvent
 */
message TouchEvent {
  View v = 1;
  /*
  See the Android documentation for MotionEvent for info.
   */
  enum Action {
    down = 0;
    up = 1;
    pointerDown = 2;
    pointerUp = 3;
    cancel = 4;
    move = 5;
  }
  Action action = 2;
  message Touch {
    /*
    A pointer on the display.
     */
    message Pointer {
      /*
      Coordinates inside the View.
       */
      int32 x = 1;
      int32 y = 2;
      /*
      The pointer id.
       */
      int32 id = 3;
    }
    /*
    A list of pointer currently touching the display.
     */
    repeated Pointer pointers = 4;
  }
  /*
  The touches in this event. Multiple can be returned if it's a move event.
   */
  repeated Touch touches = 3;
  /*
  The pointer index the event is for, if any.
   */
  int32 index = 4;
  /*
  A timestamp for when the event happened, use for gestures and the like.
   */
  uint64 time = 5;
}

message MouseEvent {
  View v = 1;
  /*
  See the Android documentation for MotionEvent for info.
   */
  enum Action {
    hoverEnter = 0;
    hoverExit = 1;
    hoverMove = 2;
    buttonPress = 3;
    buttonRelease = 4;
  }
  Action action = 2;
  int32 button = 3;
  message Pointer {
    /*
    Coordinates inside the View.
     */
    int32 x = 1;
    int32 y = 2;
  }
  Pointer pointer = 4;
  /*
  A timestamp for when the event happened, use for gestures and the like.
   */
  uint64 time = 5;
}

/*
Send when a SwipeRefreshLayout is refreshed. Automatically enabled.
 */
message RefreshEvent {
  View v = 1;
}

/*
Send when a RadioButton is selected in a RadioGroup. Automatically enabled.
 */
message SelectedEvent {
  View v = 1;
  /*
  The id of the currently selected RadioButton in the group-
   */
  int32 selected = 2;
}

/*
Send when an item or tab is selected in a Spinner or TabLayout. Automatically enabled.
 */
message ItemSelectedEvent {
  View v = 1;
  /*
  The index of the tab/item.
  -1 if nothing was selected.
   */
  int32 selected = 2;
}

/*
Send when a back button press is intercepted.
 */
message BackButtonEvent {
  int32 aid = 1;
}

/*
Send when text changes in a TextView. Unreliable.
 */
message TextEvent {
  View v = 1;
  string text = 2;
}

/*
Send when a navigation was attempted in a WebView.
 */
message WebViewNavigationEvent {
  View v = 1;
  string url = 2;
}

/*
Send when an HTTP error happened in a WebView.
 */
message WebViewHTTPErrorEvent {
  View v = 1;
  string url = 2;
  int32 code = 3;
}

/*
Send when an error happened in a WebView.
 */
message WebViewErrorEvent {
  View v = 1;
  string url = 2;
}

/*
Send when a WebView was destroyed by the system. You have to delete and recreate it.
 */
message WebViewDestroyedEvent {
  View v = 1;
}

/*
Send when the progress bar changes in a WebView.
 */
message WebViewProgressEvent {
  View v = 1;
  uint32 progress = 2;
}

/*
Send when JS writes a console message in a WebView.
 */
message WebViewConsoleMessageEvent {
  View v = 1;
  string message = 2;
}

/*
Send when Airplane mode changes.
 */
message AirplaneEvent {
  bool active = 1;
}

/*
Send when the locale changes.
 */
message LocaleEvent {
  string locale = 1;
}


/*
Send when the timezone changes.
 */
message TimezoneEvent {
  string tz = 1;
}

/*
Send when the screen is turned off.
 */
message ScreenOffEvent {
  
}

/*
Send when the screen is turned on.
 */
message ScreenOnEvent {
  
}

/*
Send when the user leaves an Activity.
This is the right moment to enter PiP-mode if you need to.
 */
message UserLeaveHintEvent {
  int32 aid = 1;
}

/*
Send when PiP-mode changes.
 */
message PiPChangedEvent {
  int32 aid = 1;
  bool pip = 2;
}

/*
Send for a click in a remote layout.
 */
message RemoteClickEvent {
  uint32 rid = 1;
  uint32 id = 2;
}

/*
Send when the user taps a notification.
 */
message NotificationEvent {
  uint32 id = 1;
}

/*
Send when the user dismisses a notification.
 */
message NotificationDismissedEvent {
  uint32 id = 1;
}

/*
Send when the user presses a notification action.
 */
message NotificationActionEvent {
  uint32 id = 1;
  uint32 action = 2;
}

/*
Send when a pinch gesture is used on an overlay Activity. Unreliable.
 */
message OverlayScaleEvent {
  int32 aid = 1;
  float span = 2;
}

/*
Send when an ImageView or SurfaceView is set to use the keyboard.
 */
message KeyEvent {
  enum Modifier {
    MOD_NONE = 0;
    MOD_LSHIFT = 1;
    MOD_RSHIFT = 2;
    MOD_LCTRL = 4;
    MOD_RCTRL = 8;
    MOD_ALT = 16;
    MOD_FN = 32;
    MOD_CAPS_LOCK = 64;
    MOD_ALT_GR = 128;
    MOD_NUM_LOCK = 256;
  }
  View v = 1;
  uint32 code = 2; // The Android keycode, refer to https://developer.android.com/reference/android/view/KeyEvent for the values. Values are provided in the KeyCode enum.
  uint32 modifiers = 3; // Bits are according to the Modifier enum.
  uint32 codePoint = 4; // The unicode code point of the character.
  KeyAction action = 5; // The Action, that is if the key was pressed or released.
  uint32 flags = 6; // The flags of the key event.
}


/*
Send for each frame for a SurfaceView. You should try to submit a frame as fast as possible after this,
and not submit another one until the next event, to prevent rendering images that don't get shown to the user.
 */
message SurfaceViewFrameCompleteEvent {
  /*
  The id of the SurfaceView.
   */
  View v = 1;
  /*
  The timestamp for the frame rendering completion in milliseconds since system boot.
   */
  uint64 timestamp = 2;
}


/*
Send when the Surface of a SurfaceView changes. If the size is different, your next buffer should have the updated size.
 */
message SurfaceViewSurfaceChangedEvent {
  /*
  The id of the SurfaceView.
   */
  View v = 1;
  /*
  The new width of the Surface.
   */
  uint32 width = 2;
  /*
  The new height of the Surface.
   */
  uint32 height = 3;
}


/*
Send when a volume key is pressed and it was configured to be intercepted.
Down presses are repeated as long as the key is down.
 */
message VolumeKeyEvent {
  int32 aid = 1;
  /*
  The Volume keys.
   */
  enum VolumeKey {
    /*
    Volume up.
     */
    VOLUME_UP = 0;
    /*
    Volume down.
     */
    VOLUME_DOWN = 1;
  }
  /*
  Which volume key was pressed.
   */
  VolumeKey key = 2;
  /*
  Whether the key was pressed or released.
   */
  bool released = 3;
}


/*
Send when the system bar status changes.
 */
message InsetEvent {
  int32 aid = 1;
  /*
  The bars that are now visible.
   */
  ConfigureInsetsRequest.Bars visible = 2;
}


// Debug events


message Event {
  oneof event {
    ClickEvent click = 1;
    TouchEvent touch = 2;
    TextEvent text = 3;
    MouseEvent mouse = 4;

    
    CreateEvent create = 16;
    StartEvent start = 17;
    ResumeEvent resume = 18;
    PauseEvent pause = 19;
    StopEvent stop = 20;
    DestroyEvent destroy = 21;
    ConfigEvent config = 22;
    LongClickEvent longClick = 23;
    FocusChangeEvent focusChange = 24;
    RefreshEvent refresh = 26;
    SelectedEvent selected = 27;
    ItemSelectedEvent itemSelected = 28;
    BackButtonEvent back = 29;
    WebViewNavigationEvent webNavigation = 30;
    WebViewHTTPErrorEvent webHTTPError = 31;
    WebViewErrorEvent webError = 32;
    WebViewDestroyedEvent webDestroyed = 33;
    WebViewProgressEvent webProgress = 34;
    WebViewConsoleMessageEvent webConsoleMessage = 35;
    AirplaneEvent airplane = 36;
    LocaleEvent locale = 37;
    TimezoneEvent timezone = 38;
    ScreenOffEvent screenOff = 39;
    ScreenOnEvent screenOn = 40;
    UserLeaveHintEvent userLeaveHint = 41;
    PiPChangedEvent pip = 42;
    RemoteClickEvent remoteClick = 43;
    NotificationEvent notification = 44;
    NotificationDismissedEvent notificationDismissed = 45;
    NotificationActionEvent notificationAction = 46;
    OverlayScaleEvent overlayScale = 47;
    KeyEvent keyEvent = 48;
    SurfaceViewFrameCompleteEvent frameComplete = 49;
    VolumeKeyEvent volume = 50;
    InsetEvent inset = 51;
    SurfaceViewSurfaceChangedEvent surfaceChanged = 52;
    
    // Debug events
    
    
    
    
    
    
    
  }
}


enum KeyAction {
  /**
   * {@link #getAction} value: the key has been pressed down.
   */
  ACTION_DOWN = 0;
  /**
   * {@link #getAction} value: the key has been released.
   */
  ACTION_UP = 1;
}


enum KeyFlag {
  FLAG_NONE = 0;
  
  /**
   * This mask is set if the key event was generated by a software keyboard.
   */
  FLAG_SOFT_KEYBOARD = 0x2;

  /**
   * This mask is set if we don't want the key event to cause us to leave
   * touch mode.
   */
    FLAG_KEEP_TOUCH_MODE = 0x4;

  /**
   * This mask is set if an event was known to come from a trusted part
   * of the system.  That is, the event is known to come from the user,
   * and could not have been spoofed by a third party component.
   */
    FLAG_FROM_SYSTEM = 0x8;

  /**
   * This mask is used for compatibility, to identify enter keys that are
   * coming from an IME whose enter key has been auto-labelled "next" or
   * "done".  This allows TextView to dispatch these as normal enter keys
   * for old applications, but still do the appropriate action when
   * receiving them.
   */
    FLAG_EDITOR_ACTION = 0x10;

  /**
   * When associated with up key events, this indicates that the key press
   * has been canceled.  Typically this is used with virtual touch screen
   * keys, where the user can slide from the virtual key area on to the
   * display: in that case, the application will receive a canceled up
   * event and should not perform the action normally associated with the
   * key.  Note that for this to work, the application can not perform an
   * action for a key until it receives an up or the long press timeout has
   * expired.
   */
    FLAG_CANCELED = 0x20;

  /**
   * This key event was generated by a virtual (on-screen) hard key area.
   * Typically this is an area of the touchscreen, outside of the regular
   * display, dedicated to "hardware" buttons.
   */
    FLAG_VIRTUAL_HARD_KEY = 0x40;

  /**
   * This flag is set for the first key repeat that occurs after the
   * long press timeout.
   */
    FLAG_LONG_PRESS = 0x80;

  /**
   * Set when a key event has {@link #FLAG_CANCELED} set because a long
   * press action was executed while it was down.
   */
    FLAG_CANCELED_LONG_PRESS = 0x100;

  /**
   * Set for {@link #ACTION_UP} when this event's key code is still being
   * tracked from its initial down.  That is, somebody requested that tracking
   * started on the key down and a long press has not caused
   * the tracking to be canceled.
   */
    FLAG_TRACKING = 0x200;

  /**
   * Set when a key event has been synthesized to implement default behavior
   * for an event that the application did not handle.
   * Fallback key events are generated by unhandled trackball motions
   * (to emulate a directional keypad) and by certain unhandled key presses
   * that are declared in the key map (such as special function numeric keypad
   * keys when numlock is off).
   */
    FLAG_FALLBACK = 0x400;
}

// Auto-generated from Android SDK sources, DO NOT TOUCH
/// For documentation, see https://developer.android.com/reference/android/view/KeyEvent#KEYCODE_0
enum KeyCode {
KEYCODE_UNKNOWN          =  0;
KEYCODE_SOFT_LEFT        =  1;
KEYCODE_SOFT_RIGHT       =  2;
KEYCODE_HOME             =  3;
KEYCODE_BACK             =  4;
KEYCODE_CALL             =  5;
KEYCODE_ENDCALL          =  6;
KEYCODE_0                =  7;
KEYCODE_1                =  8;
KEYCODE_2                =  9;
KEYCODE_3                =  10;
KEYCODE_4                =  11;
KEYCODE_5                =  12;
KEYCODE_6                =  13;
KEYCODE_7                =  14;
KEYCODE_8                =  15;
KEYCODE_9                =  16;
KEYCODE_STAR             =  17;
KEYCODE_POUND            =  18;
KEYCODE_DPAD_UP          =  19;
KEYCODE_DPAD_DOWN        =  20;
KEYCODE_DPAD_LEFT        =  21;
KEYCODE_DPAD_RIGHT       =  22;
KEYCODE_DPAD_CENTER      =  23;
KEYCODE_VOLUME_UP        =  24;
KEYCODE_VOLUME_DOWN      =  25;
KEYCODE_POWER            =  26;
KEYCODE_CAMERA           =  27;
KEYCODE_CLEAR            =  28;
KEYCODE_A                =  29;
KEYCODE_B                =  30;
KEYCODE_C                =  31;
KEYCODE_D                =  32;
KEYCODE_E                =  33;
KEYCODE_F                =  34;
KEYCODE_G                =  35;
KEYCODE_H                =  36;
KEYCODE_I                =  37;
KEYCODE_J                =  38;
KEYCODE_K                =  39;
KEYCODE_L                =  40;
KEYCODE_M                =  41;
KEYCODE_N                =  42;
KEYCODE_O                =  43;
KEYCODE_P                =  44;
KEYCODE_Q                =  45;
KEYCODE_R                =  46;
KEYCODE_S                =  47;
KEYCODE_T                =  48;
KEYCODE_U                =  49;
KEYCODE_V                =  50;
KEYCODE_W                =  51;
KEYCODE_X                =  52;
KEYCODE_Y                =  53;
KEYCODE_Z                =  54;
KEYCODE_COMMA            =  55;
KEYCODE_PERIOD           =  56;
KEYCODE_ALT_LEFT         =  57;
KEYCODE_ALT_RIGHT        =  58;
KEYCODE_SHIFT_LEFT       =  59;
KEYCODE_SHIFT_RIGHT      =  60;
KEYCODE_TAB              =  61;
KEYCODE_SPACE            =  62;
KEYCODE_SYM              =  63;
KEYCODE_EXPLORER         =  64;
KEYCODE_ENVELOPE         =  65;
KEYCODE_ENTER            =  66;
KEYCODE_DEL              =  67;
KEYCODE_GRAVE            =  68;
KEYCODE_MINUS            =  69;
KEYCODE_EQUALS           =  70;
KEYCODE_LEFT_BRACKET     =  71;
KEYCODE_RIGHT_BRACKET    =  72;
KEYCODE_BACKSLASH        =  73;
KEYCODE_SEMICOLON        =  74;
KEYCODE_APOSTROPHE       =  75;
KEYCODE_SLASH            =  76;
KEYCODE_AT               =  77;
KEYCODE_NUM              =  78;
KEYCODE_HEADSETHOOK      =  79;
KEYCODE_FOCUS            =  80;
KEYCODE_PLUS             =  81;
KEYCODE_MENU             =  82;
KEYCODE_NOTIFICATION     =  83;
KEYCODE_SEARCH           =  84;
KEYCODE_MEDIA_PLAY_PAUSE =  85;
KEYCODE_MEDIA_STOP       =  86;
KEYCODE_MEDIA_NEXT       =  87;
KEYCODE_MEDIA_PREVIOUS   =  88;
KEYCODE_MEDIA_REWIND     =  89;
KEYCODE_MEDIA_FAST_FORWARD  =  90;
KEYCODE_MUTE             =  91;
KEYCODE_PAGE_UP          =  92;
KEYCODE_PAGE_DOWN        =  93;
KEYCODE_PICTSYMBOLS      =  94;
KEYCODE_SWITCH_CHARSET   =  95;
KEYCODE_BUTTON_A         =  96;
KEYCODE_BUTTON_B         =  97;
KEYCODE_BUTTON_C         =  98;
KEYCODE_BUTTON_X         =  99;
KEYCODE_BUTTON_Y         =  100;
KEYCODE_BUTTON_Z         =  101;
KEYCODE_BUTTON_L1        =  102;
KEYCODE_BUTTON_R1        =  103;
KEYCODE_BUTTON_L2        =  104;
KEYCODE_BUTTON_R2        =  105;
KEYCODE_BUTTON_THUMBL    =  106;
KEYCODE_BUTTON_THUMBR    =  107;
KEYCODE_BUTTON_START     =  108;
KEYCODE_BUTTON_SELECT    =  109;
KEYCODE_BUTTON_MODE      =  110;
KEYCODE_ESCAPE           =  111;
KEYCODE_FORWARD_DEL      =  112;
KEYCODE_CTRL_LEFT        =  113;
KEYCODE_CTRL_RIGHT       =  114;
KEYCODE_CAPS_LOCK        =  115;
KEYCODE_SCROLL_LOCK      =  116;
KEYCODE_META_LEFT        =  117;
KEYCODE_META_RIGHT       =  118;
KEYCODE_FUNCTION         =  119;
KEYCODE_SYSRQ            =  120;
KEYCODE_BREAK            =  121;
KEYCODE_MOVE_HOME        =  122;
KEYCODE_MOVE_END         =  123;
KEYCODE_INSERT           =  124;
KEYCODE_FORWARD          =  125;
KEYCODE_MEDIA_PLAY       =  126;
KEYCODE_MEDIA_PAUSE      =  127;
KEYCODE_MEDIA_CLOSE      =  128;
KEYCODE_MEDIA_EJECT      =  129;
KEYCODE_MEDIA_RECORD     =  130;
KEYCODE_F1               =  131;
KEYCODE_F2               =  132;
KEYCODE_F3               =  133;
KEYCODE_F4               =  134;
KEYCODE_F5               =  135;
KEYCODE_F6               =  136;
KEYCODE_F7               =  137;
KEYCODE_F8               =  138;
KEYCODE_F9               =  139;
KEYCODE_F10              =  140;
KEYCODE_F11              =  141;
KEYCODE_F12              =  142;
KEYCODE_NUM_LOCK         =  143;
KEYCODE_NUMPAD_0         =  144;
KEYCODE_NUMPAD_1         =  145;
KEYCODE_NUMPAD_2         =  146;
KEYCODE_NUMPAD_3         =  147;
KEYCODE_NUMPAD_4         =  148;
KEYCODE_NUMPAD_5         =  149;
KEYCODE_NUMPAD_6         =  150;
KEYCODE_NUMPAD_7         =  151;
KEYCODE_NUMPAD_8         =  152;
KEYCODE_NUMPAD_9         =  153;
KEYCODE_NUMPAD_DIVIDE    =  154;
KEYCODE_NUMPAD_MULTIPLY  =  155;
KEYCODE_NUMPAD_SUBTRACT  =  156;
KEYCODE_NUMPAD_ADD       =  157;
KEYCODE_NUMPAD_DOT       =  158;
KEYCODE_NUMPAD_COMMA     =  159;
KEYCODE_NUMPAD_ENTER     =  160;
KEYCODE_NUMPAD_EQUALS    =  161;
KEYCODE_NUMPAD_LEFT_PAREN  =  162;
KEYCODE_NUMPAD_RIGHT_PAREN  =  163;
KEYCODE_VOLUME_MUTE      =  164;
KEYCODE_INFO             =  165;
KEYCODE_CHANNEL_UP       =  166;
KEYCODE_CHANNEL_DOWN     =  167;
KEYCODE_ZOOM_IN          =  168;
KEYCODE_ZOOM_OUT         =  169;
KEYCODE_TV               =  170;
KEYCODE_WINDOW           =  171;
KEYCODE_GUIDE            =  172;
KEYCODE_DVR              =  173;
KEYCODE_BOOKMARK         =  174;
KEYCODE_CAPTIONS         =  175;
KEYCODE_SETTINGS         =  176;
KEYCODE_TV_POWER         =  177;
KEYCODE_TV_INPUT         =  178;
KEYCODE_STB_POWER        =  179;
KEYCODE_STB_INPUT        =  180;
KEYCODE_AVR_POWER        =  181;
KEYCODE_AVR_INPUT        =  182;
KEYCODE_PROG_RED         =  183;
KEYCODE_PROG_GREEN       =  184;
KEYCODE_PROG_YELLOW      =  185;
KEYCODE_PROG_BLUE        =  186;
KEYCODE_APP_SWITCH       =  187;
KEYCODE_BUTTON_1         =  188;
KEYCODE_BUTTON_2         =  189;
KEYCODE_BUTTON_3         =  190;
KEYCODE_BUTTON_4         =  191;
KEYCODE_BUTTON_5         =  192;
KEYCODE_BUTTON_6         =  193;
KEYCODE_BUTTON_7         =  194;
KEYCODE_BUTTON_8         =  195;
KEYCODE_BUTTON_9         =  196;
KEYCODE_BUTTON_10        =  197;
KEYCODE_BUTTON_11        =  198;
KEYCODE_BUTTON_12        =  199;
KEYCODE_BUTTON_13        =  200;
KEYCODE_BUTTON_14        =  201;
KEYCODE_BUTTON_15        =  202;
KEYCODE_BUTTON_16        =  203;
KEYCODE_LANGUAGE_SWITCH  =  204;
KEYCODE_MANNER_MODE      =  205;
KEYCODE_3D_MODE          =  206;
KEYCODE_CONTACTS         =  207;
KEYCODE_CALENDAR         =  208;
KEYCODE_MUSIC            =  209;
KEYCODE_CALCULATOR       =  210;
KEYCODE_ZENKAKU_HANKAKU  =  211;
KEYCODE_EISU             =  212;
KEYCODE_MUHENKAN         =  213;
KEYCODE_HENKAN           =  214;
KEYCODE_KATAKANA_HIRAGANA  =  215;
KEYCODE_YEN              =  216;
KEYCODE_RO               =  217;
KEYCODE_KANA             =  218;
KEYCODE_ASSIST           =  219;
KEYCODE_BRIGHTNESS_DOWN  =  220;
KEYCODE_BRIGHTNESS_UP    =  221;
KEYCODE_MEDIA_AUDIO_TRACK  =  222;
KEYCODE_SLEEP            =  223;
KEYCODE_WAKEUP           =  224;
KEYCODE_PAIRING          =  225;
KEYCODE_MEDIA_TOP_MENU   =  226;
KEYCODE_11               =  227;
KEYCODE_12               =  228;
KEYCODE_LAST_CHANNEL     =  229;
KEYCODE_TV_DATA_SERVICE  =  230;
KEYCODE_VOICE_ASSIST  =  231;
KEYCODE_TV_RADIO_SERVICE  =  232;
KEYCODE_TV_TELETEXT  =  233;
KEYCODE_TV_NUMBER_ENTRY  =  234;
KEYCODE_TV_TERRESTRIAL_ANALOG  =  235;
KEYCODE_TV_TERRESTRIAL_DIGITAL  =  236;
KEYCODE_TV_SATELLITE  =  237;
KEYCODE_TV_SATELLITE_BS  =  238;
KEYCODE_TV_SATELLITE_CS  =  239;
KEYCODE_TV_SATELLITE_SERVICE  =  240;
KEYCODE_TV_NETWORK  =  241;
KEYCODE_TV_ANTENNA_CABLE  =  242;
KEYCODE_TV_INPUT_HDMI_1  =  243;
KEYCODE_TV_INPUT_HDMI_2  =  244;
KEYCODE_TV_INPUT_HDMI_3  =  245;
KEYCODE_TV_INPUT_HDMI_4  =  246;
KEYCODE_TV_INPUT_COMPOSITE_1  =  247;
KEYCODE_TV_INPUT_COMPOSITE_2  =  248;
KEYCODE_TV_INPUT_COMPONENT_1  =  249;
KEYCODE_TV_INPUT_COMPONENT_2  =  250;
KEYCODE_TV_INPUT_VGA_1  =  251;
KEYCODE_TV_AUDIO_DESCRIPTION  =  252;
KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP  =  253;
KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN  =  254;
KEYCODE_TV_ZOOM_MODE  =  255;
KEYCODE_TV_CONTENTS_MENU  =  256;
KEYCODE_TV_MEDIA_CONTEXT_MENU  =  257;
KEYCODE_TV_TIMER_PROGRAMMING  =  258;
KEYCODE_HELP  =  259;
KEYCODE_NAVIGATE_PREVIOUS  =  260;
KEYCODE_NAVIGATE_NEXT    =  261;
KEYCODE_NAVIGATE_IN      =  262;
KEYCODE_NAVIGATE_OUT     =  263;
KEYCODE_STEM_PRIMARY  =  264;
KEYCODE_STEM_1  =  265;
KEYCODE_STEM_2  =  266;
KEYCODE_STEM_3  =  267;
KEYCODE_DPAD_UP_LEFT     =  268;
KEYCODE_DPAD_DOWN_LEFT   =  269;
KEYCODE_DPAD_UP_RIGHT    =  270;
KEYCODE_DPAD_DOWN_RIGHT  =  271;
KEYCODE_MEDIA_SKIP_FORWARD  =  272;
KEYCODE_MEDIA_SKIP_BACKWARD  =  273;
KEYCODE_MEDIA_STEP_FORWARD  =  274;
KEYCODE_MEDIA_STEP_BACKWARD  =  275;
KEYCODE_SOFT_SLEEP  =  276;
KEYCODE_CUT  =  277;
KEYCODE_COPY  =  278;
KEYCODE_PASTE  =  279;
KEYCODE_SYSTEM_NAVIGATION_UP  =  280;
KEYCODE_SYSTEM_NAVIGATION_DOWN  =  281;
KEYCODE_SYSTEM_NAVIGATION_LEFT  =  282;
KEYCODE_SYSTEM_NAVIGATION_RIGHT  =  283;
KEYCODE_ALL_APPS  =  284;
KEYCODE_REFRESH  =  285;
KEYCODE_THUMBS_UP  =  286;
KEYCODE_THUMBS_DOWN  =  287;
KEYCODE_PROFILE_SWITCH  =  288;
KEYCODE_VIDEO_APP_1  =  289;
KEYCODE_VIDEO_APP_2  =  290;
KEYCODE_VIDEO_APP_3  =  291;
KEYCODE_VIDEO_APP_4  =  292;
KEYCODE_VIDEO_APP_5  =  293;
KEYCODE_VIDEO_APP_6  =  294;
KEYCODE_VIDEO_APP_7  =  295;
KEYCODE_VIDEO_APP_8  =  296;
KEYCODE_FEATURED_APP_1  =  297;
KEYCODE_FEATURED_APP_2  =  298;
KEYCODE_FEATURED_APP_3  =  299;
KEYCODE_FEATURED_APP_4  =  300;
KEYCODE_DEMO_APP_1  =  301;
KEYCODE_DEMO_APP_2  =  302;
KEYCODE_DEMO_APP_3  =  303;
KEYCODE_DEMO_APP_4  =  304;
KEYCODE_KEYBOARD_BACKLIGHT_DOWN  =  305;
KEYCODE_KEYBOARD_BACKLIGHT_UP  =  306;
KEYCODE_KEYBOARD_BACKLIGHT_TOGGLE  =  307;
KEYCODE_STYLUS_BUTTON_PRIMARY  =  308;
KEYCODE_STYLUS_BUTTON_SECONDARY  =  309;
KEYCODE_STYLUS_BUTTON_TERTIARY  =  310;
KEYCODE_STYLUS_BUTTON_TAIL  =  311;
KEYCODE_RECENT_APPS  =  312;
KEYCODE_MACRO_1  =  313;
KEYCODE_MACRO_2  =  314;
KEYCODE_MACRO_3  =  315;
KEYCODE_MACRO_4  =  316;
}


